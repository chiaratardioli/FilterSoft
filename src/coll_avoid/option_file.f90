!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                           !!
!!                   MODULE FOR OPTIONS                      !!
!!                                                           !!
!!              Chiara Tardioli, Sep 19,2012                 !!
!!                                                           !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! ============================================================
! Contains
! declarations and setting of costants
! read_opton : set option variables
! ============================================================
MODULE option_file
  USE fund_const

!!!!!!! MEMORIA DANNEGGIATA norbx < 10.000 !!!!!!!!!!!
  INTEGER,PARAMETER :: norbx=5000   !max no. of input orbit
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  INTEGER,PARAMETER :: tmax=10000    !max no. of evolution time nodes
  REAL(KIND=dkind) :: teph0        !initial epoch
  REAL(KIND=dkind) :: dt           !interpolation time step (days)
  INTEGER :: nevol                 !no. of evolution time nodes
  INTEGER :: hevol                 !no. of evolution time nodes
  REAL(KIND=dkind) :: d_thres      !threshold (km)
  INTEGER :: iun1,iun2             !for detail outputs

  PUBLIC :: norbx,tmax,teph0,dt,hevol,d_thres,iun1,iun2,nevol
  PUBLIC :: read_options,read_lenz,read_lenz_unc,set_hevol
 
CONTAINS

! ************************************************************
!        READ ORBIT EVOLUTIONS
! ************************************************************
  SUBROUTINE set_hevol(iunda)
    REAL(KIND=dkind) :: tevol
! ---------------------------------------------------
    READ(iunda,REC=nevol)tevol
    hevol=FLOOR(tevol/dt)
  END SUBROUTINE set_hevol
  
! ************************************************************
!        READ OPTION FROM FILE
! ************************************************************
SUBROUTINE read_options
  IMPLICIT NONE
  INTEGER :: iunit
! ---------------------------------------
  rhs=2
!  CALL filopn(iunit,'cross.opt','OLD')
!  CALL skip(iunit,1)
!  READ(iunit,*)norbx,tmax,teph0,dt
!  CALL filclo(iunit,' ')

!  norbx=864
!  tmax=3000
  teph0=55000.d0
!  dt=0.025d0
!  dt=1.25d-2
  dt=0.0052083d0
  d_thres=2.d0 !1.d0

! for a detailed output 
!  iun1=98
!  iun2=99

END SUBROUTINE read_options

! *********************************************
! READING ORBIT DATA GENERATED BY KEPINT_LENZ
! COVARIANCE MATRICES are read if read_cov is true
! *********************************************
SUBROUTINE read_lenz(norb,namelenz,elem)
  USE orbit_elements
  IMPLICIT NONE
! ----------------- interface -----------------------------------
  INTEGER,INTENT(OUT) :: norb !number of satellites in input
  CHARACTER*9,DIMENSION(norbx),INTENT(OUT) :: namelenz
  TYPE(orbit_elem),DIMENSION(norbx),INTENT(OUT) :: elem
! ---------------- end interface --------------------------------
  CHARACTER*9,DIMENSION(norbx) :: namecov !satellite names
  INTEGER :: iunorb,i,fail_flag
! --------------------------------------------------------------
!  ***** start reading orbit data *****
  CALL filopn(iunorb,'allslenzall_nor.out.orbit','OLD')
!  CALL filopn(iunorb,'nearlenzall_nor.out.orbit','OLD')

  CALL skip(iunorb,1)
  DO i=1,norbx
     elem(i)=undefined_orbit_elem
     READ(iunorb,*,END=998) namelenz(i),elem(i)%coo,elem(i)%coord(1:6), &
          & elem(i)%h_mag,elem(i)%t
! converting angles in radiant
     elem(i)%coord(3:6) = elem(i)%coord(3:6)*radeg
! check: orbital elements must be KEP
     IF(elem(i)%coo.ne.'KEP')THEN
!        WRITE(*,*)'read_elem_sat: converting orbit elem to KEP'
        CALL coo_cha(elem(i),'KEP',elem(i),fail_flag)
        IF(fail_flag.ge.5) THEN
           WRITE(*,*)'read_elem_sat: coo_cha fail_flag=',fail_flag
           STOP
        ENDIF
     ENDIF
! converting s.m.axis in meters
     elem(i)%coord(1)=elem(i)%coord(1)*1.d3
  ENDDO
  write(*,*)'do loop too short!',i
  STOP
998 CONTINUE
! ***** end reading orbits *****
  CALL filclo(iunorb,' ')
  norb=i-1

END SUBROUTINE read_lenz

! *********************************************
! READING ORBIT DATA GENERATED BY KEPINT_LENZ
! COVARIANCE MATRICES are read if read_cov is true
! *********************************************
! SUBROUTINE read_lenz_unc(norb,namelenz,elem,unc,rms_orb)
SUBROUTINE read_lenz_unc(norb,namelenz,elem,rms_orb)
  USE orbit_elements
  IMPLICIT NONE
!  INTEGER,PARAMETER :: norbx=1200
! ----------------- interface -----------------------------------
  INTEGER,INTENT(OUT) :: norb !number of satellites in input
  CHARACTER*9,DIMENSION(norbx),INTENT(OUT) :: namelenz
  TYPE(orbit_elem),DIMENSION(norbx),INTENT(OUT) :: elem
!  TYPE(orb_uncert),DIMENSION(norbx),INTENT(OUT) :: unc
  TYPE(orb_uncert),DIMENSION(norbx) :: unc
  REAL(KIND=dkind),DIMENSION(norbx,6),INTENT(OUT) :: rms_orb
! ---------------- end interface --------------------------------
  CHARACTER*9,DIMENSION(norbx) :: namecov !satellite names
  LOGICAL :: read_cov=.true.
  INTEGER :: norbcov,n
  CHARACTER*3 :: cov !auxiliar character
  REAL(KIND=dkind),DIMENSION(3) :: vec !auxiliar vector
  REAL(KIND=dkind),DIMENSION(6,6) :: jaccomel
  INTEGER :: iunorb,iuncov,i,j,k,r,c,fail_flag
! --------------------------------------------------------------
! data analysis
  LOGICAL :: check_data=.false.
  INTEGER :: iunout
  CHARACTER*1 :: char_com
  CHARACTER*3 :: char_rms
! ==============================================================

!  ***** start reading orbit data *****
  CALL filopn(iunorb,'allslenzall_nor.out.orbit','OLD')
!  CALL filopn(iunorb,'nearlenzall_nor.out.orbit','OLD')

  CALL skip(iunorb,1)
  DO i=1,norbx
     elem(i)=undefined_orbit_elem
     unc(i)=undefined_orb_uncert
    
     READ(iunorb,*,END=998) namelenz(i),elem(i)%coo,elem(i)%coord(1:6), &
          & elem(i)%h_mag,elem(i)%t
! converting angles in radiant
     elem(i)%coord(3:6) = elem(i)%coord(3:6)*radeg
! check: orbital elements must be KEP
     IF(elem(i)%coo.ne.'KEP')THEN
!        WRITE(*,*)'read_elem_sat: converting orbit elem to KEP'
        CALL coo_cha(elem(i),'KEP',elem(i),fail_flag)
        IF(fail_flag.ge.5) THEN
           WRITE(*,*)'read_elem_sat: coo_cha fail_flag=',fail_flag
           STOP
        ENDIF
     ENDIF
     ! converting s.m.axis in meters
     elem(i)%coord(1)=elem(i)%coord(1)*1.d3
  ENDDO
  write(*,*)'do loop too short!',i
  STOP
998 CONTINUE
! ***** end reading orbits *****
  CALL filclo(iunorb,' ')
  norb=i-1

! ****** start reading cavariance matrices ****
  CALL filopn(iuncov,'allslenzall_nor.out.covariance','OLD')
!  CALL filopn(iuncov,'nearlenzall_nor.out.covariance','OLD')

  CALL skip(iuncov,2)
  DO i=1,norbx
     READ(iuncov,*,END=999)namecov(i),n
! check
     IF(namecov(i).ne.namelenz(i))THEN
        write(*,*)'read_lenz_unc: error orbir-matrix corrispondence ',i
        STOP
     ENDIF
     r=1
     c=1
     DO j=1,7
        READ(iuncov,*) cov,vec
        DO k=1,3
           unc(i)%g(r,c)=vec(k)
           IF(c.ne.r)THEN
              unc(i)%g(c,r)=unc(i)%g(r,c)
           ENDIF
           IF(c.ge.6)THEN
              r=r+1
              c=r
           ELSE
              c=c+1
           ENDIF
        ENDDO
     ENDDO
     CALL skip(iuncov,7)
! reading RMS line
     read(iuncov,*) char_com,char_rms,rms_orb(i,1:6)
     CALL skip(iuncov,2)
  ENDDO
  write(*,*)'do loop too short!',i
  STOP
999 CONTINUE
! ***** end reading COV matrices ******
  CALL filclo(iuncov,' ')
  norbcov=i-1

! check
  IF(norb.ne.norbcov)THEN
     write(*,*)'different no. of orbits!!!!',norb,'  ',norbcov
  ENDIF

  IF(check_data)THEN
! ***** output orbit data to analyse *****
     CALL filopn(iunout,'orbit_data.fla','UNKNOWN')
     write(*,*)'orbit_data file : orb_index,elem(1:5),rms(1:5)'
     DO i=1,norb
        write(iunout,107)i,elem(i)%coord(1)*(1.d0-elem(i)%coord(2)), &
             & elem(i)%coord(2),elem(i)%coord(3:5)*degrad,rms_orb(i,1:6)
     ENDDO
107  FORMAT(i3,1x,f15.7,1x,f12.10,3(1x,f12.8),5(1x,es11.5))
     CALL filclo(iunout,' ')
  ENDIF

  write(*,*)elem(1)%coord
  write(*,*)rms_orb(1,:)
END SUBROUTINE read_lenz_unc

END MODULE option_file
